//! ADNL TCP handshake implementation.
//!
//! The ADNL handshake establishes an encrypted channel between client and server.
//! Based on official TON implementation (ton-blockchain/ton):
//!
//! 1. Client generates 160 random bytes
//! 2. Client derives cipher keys from these bytes (for session encryption)
//! 3. Client generates an EPHEMERAL Ed25519 keypair (just for handshake encryption)
//! 4. Client calculates ECDH shared secret: ephemeral_private_key * server_public_key
//! 5. Client sends handshake packet (256 bytes):
//!    - server_key_id: 32 bytes (SHA256 of TL-serialized server pubkey)
//!    - ephemeral_pubkey: 32 bytes (ephemeral public key, NOT client's persistent key)
//!    - checksum: 32 bytes (SHA256 of 160 random bytes)
//!    - encrypted_params: 160 bytes (AES-CTR encrypted random bytes)
//! 6. Server responds with an empty ADNL packet to confirm

use ton_crypto::{
    aes_ctr::AesCtrCipher,
    ed25519::Ed25519Keypair,
    keys::calculate_key_id,
    sha256::sha256,
    x25519::ecdh_ed25519,
};

/// Size of the handshake random parameters.
pub const HANDSHAKE_PARAMS_SIZE: usize = 160;

/// Total size of the handshake packet.
pub const HANDSHAKE_PACKET_SIZE: usize = 256; // 32 + 32 + 32 + 160

/// Handshake parameters generated by the client.
///
/// These 160 random bytes are used to derive the cipher keys
/// for the encrypted channel.
#[derive(Clone)]
pub struct HandshakeParams {
    /// The 160 random bytes.
    pub random_bytes: [u8; HANDSHAKE_PARAMS_SIZE],
}

impl HandshakeParams {
    /// Generates new random handshake parameters.
    pub fn generate() -> Self {
        use rand::RngCore;
        let mut random_bytes = [0u8; HANDSHAKE_PARAMS_SIZE];
        rand::thread_rng().fill_bytes(&mut random_bytes);
        Self { random_bytes }
    }

    /// Creates handshake parameters from existing bytes.
    pub fn from_bytes(bytes: [u8; HANDSHAKE_PARAMS_SIZE]) -> Self {
        Self { random_bytes: bytes }
    }

    /// Derives the cipher pair for encrypted communication.
    ///
    /// Returns (recv_cipher, send_cipher) where:
    /// - recv_cipher (Cipher A): Used for decrypting server->client messages
    /// - send_cipher (Cipher B): Used for encrypting client->server messages
    ///
    /// Based on TON ADNL TCP specification:
    /// - Cipher A (Server TX / Client RX): key = bytes[0..32], iv = bytes[64..80]
    /// - Cipher B (Client TX / Server RX): key = bytes[32..64], iv = bytes[80..96]
    pub fn derive_ciphers(&self) -> (AesCtrCipher, AesCtrCipher) {
        // Cipher A (recv): key = bytes[0..32], iv = bytes[64..80]
        let key_recv: [u8; 32] = self.random_bytes[0..32].try_into().unwrap();
        let iv_recv: [u8; 16] = self.random_bytes[64..80].try_into().unwrap();
        let recv_cipher = AesCtrCipher::new(key_recv, iv_recv);

        // Cipher B (send): key = bytes[32..64], iv = bytes[80..96]
        let key_send: [u8; 32] = self.random_bytes[32..64].try_into().unwrap();
        let iv_send: [u8; 16] = self.random_bytes[80..96].try_into().unwrap();
        let send_cipher = AesCtrCipher::new(key_send, iv_send);

        (recv_cipher, send_cipher)
    }

    /// Returns the SHA256 hash of the random bytes (used as checksum).
    pub fn checksum(&self) -> [u8; 32] {
        sha256(&self.random_bytes)
    }
}

/// Encrypts the handshake parameters using the ECDH shared secret.
///
/// The encryption uses a key and IV derived from the shared secret and
/// the SHA256 hash of the random bytes:
/// - Key = shared_secret[0..16] || hash[16..32]
/// - IV = hash[0..4] || shared_secret[20..32]
///
/// # Arguments
///
/// * `params` - The handshake parameters to encrypt.
/// * `shared_secret` - The 32-byte ECDH shared secret.
///
/// # Returns
///
/// The encrypted 160-byte parameters.
pub fn encrypt_handshake_params(
    params: &HandshakeParams,
    shared_secret: &[u8; 32],
) -> [u8; HANDSHAKE_PARAMS_SIZE] {
    let hash = params.checksum();

    // Key = shared_secret[0..16] || hash[16..32]
    let mut key = [0u8; 32];
    key[0..16].copy_from_slice(&shared_secret[0..16]);
    key[16..32].copy_from_slice(&hash[16..32]);

    // IV = hash[0..4] || shared_secret[20..32]
    let mut iv = [0u8; 16];
    iv[0..4].copy_from_slice(&hash[0..4]);
    iv[4..16].copy_from_slice(&shared_secret[20..32]);

    let mut cipher = AesCtrCipher::new(key, iv);
    let encrypted = cipher.encrypt(&params.random_bytes);

    encrypted.try_into().unwrap()
}

/// Builds the complete handshake packet.
///
/// The packet format (based on official TON implementation):
/// - server_key_id: 32 bytes (SHA256 of TL-serialized server pubkey)
/// - ephemeral_pubkey: 32 bytes (EPHEMERAL Ed25519 public key, NOT client's persistent key)
/// - checksum: 32 bytes (SHA256 of 160 random bytes)
/// - encrypted_params: 160 bytes (encrypted random bytes)
///
/// Total: 256 bytes
///
/// IMPORTANT: The client's persistent keypair is NOT used in the handshake.
/// Instead, an ephemeral keypair is generated for each handshake.
/// The ECDH shared secret is: ephemeral_private * server_public
///
/// # Arguments
///
/// * `server_pubkey` - The server's Ed25519 public key.
/// * `params` - The handshake parameters.
///
/// # Returns
///
/// The 256-byte handshake packet.
pub fn build_handshake_packet(
    server_pubkey: &[u8; 32],
    params: &HandshakeParams,
) -> Result<[u8; HANDSHAKE_PACKET_SIZE], ton_crypto::X25519Error> {
    // Calculate server's Key ID
    let server_key_id = calculate_key_id(server_pubkey);

    // Generate EPHEMERAL keypair just for this handshake encryption
    // This matches the official TON implementation (EncryptorEd25519::encrypt)
    let ephemeral_keypair = Ed25519Keypair::generate();

    // Calculate ECDH shared secret using EPHEMERAL private key and server's public key
    let shared_secret = ecdh_ed25519(ephemeral_keypair.private_key_bytes(), server_pubkey)?;

    // Encrypt the handshake parameters
    let encrypted_params = encrypt_handshake_params(params, &shared_secret);

    // Build the packet - using EPHEMERAL public key, not client's persistent key
    let mut packet = [0u8; HANDSHAKE_PACKET_SIZE];
    packet[0..32].copy_from_slice(&server_key_id);
    packet[32..64].copy_from_slice(&ephemeral_keypair.public_key);  // EPHEMERAL key!
    packet[64..96].copy_from_slice(&params.checksum());
    packet[96..256].copy_from_slice(&encrypted_params);

    Ok(packet)
}

/// Session ciphers for encrypted communication after handshake.
pub struct SessionCiphers {
    /// Cipher for decrypting received packets (server -> client).
    pub recv_cipher: AesCtrCipher,
    /// Cipher for encrypting sent packets (client -> server).
    pub send_cipher: AesCtrCipher,
}

impl SessionCiphers {
    /// Creates session ciphers from handshake parameters.
    pub fn from_params(params: &HandshakeParams) -> Self {
        let (recv_cipher, send_cipher) = params.derive_ciphers();
        Self {
            recv_cipher,
            send_cipher,
        }
    }
}

/// Performs the complete handshake process.
///
/// This function:
/// 1. Generates random handshake parameters (160 bytes)
/// 2. Builds the handshake packet (internally generates ephemeral keypair)
/// 3. Derives session ciphers from the random parameters
/// 4. Returns the packet and session ciphers
///
/// Note: The ephemeral keypair used for handshake encryption is generated
/// inside build_handshake_packet and is NOT the same as any persistent
/// client keypair. The client's identity is NOT established during handshake.
///
/// # Arguments
///
/// * `server_pubkey` - The server's Ed25519 public key.
///
/// # Returns
///
/// A tuple of (handshake_packet, session_ciphers), or an error
/// if the server's public key is invalid.
pub fn perform_handshake(
    server_pubkey: &[u8; 32],
) -> Result<([u8; HANDSHAKE_PACKET_SIZE], SessionCiphers), ton_crypto::X25519Error> {
    // Generate handshake parameters (160 random bytes)
    let params = HandshakeParams::generate();

    // Build handshake packet (internally generates ephemeral keypair for ECDH)
    let packet = build_handshake_packet(server_pubkey, &params)?;

    // Derive session ciphers from the random parameters
    let ciphers = SessionCiphers::from_params(&params);

    Ok((packet, ciphers))
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test that ciphers A and B are symmetric - i.e., what one encrypts,
    /// the other's counterpart on the "server" would decrypt.
    #[test]
    fn test_cipher_roundtrip_simulation() {
        // Generate random params (what client generates)
        let params = HandshakeParams::generate();

        // Client derives ciphers
        let (recv_cipher, send_cipher) = params.derive_ciphers();

        // Simulate server deriving the SAME ciphers from the SAME random_bytes
        // Server's "send" cipher is client's "recv" cipher
        // Server's "recv" cipher is client's "send" cipher
        let server_recv_key: [u8; 32] = params.random_bytes[32..64].try_into().unwrap();
        let server_recv_iv: [u8; 16] = params.random_bytes[80..96].try_into().unwrap();
        let mut server_recv_cipher = AesCtrCipher::new(server_recv_key, server_recv_iv);

        // Test: Client sends with send_cipher, server decrypts with server_recv_cipher
        let plaintext = b"Hello, TON liteserver!";
        let mut client_send = send_cipher;
        let encrypted = client_send.encrypt(plaintext);

        // Server decrypts
        let decrypted = server_recv_cipher.decrypt(&encrypted);

        assert_eq!(
            plaintext.as_slice(),
            decrypted.as_slice(),
            "Server should decrypt what client encrypted"
        );

        // Also test the reverse: server sends, client receives
        let server_send_key: [u8; 32] = params.random_bytes[0..32].try_into().unwrap();
        let server_send_iv: [u8; 16] = params.random_bytes[64..80].try_into().unwrap();
        let mut server_send_cipher = AesCtrCipher::new(server_send_key, server_send_iv);

        let server_message = b"Response from server";
        let encrypted_from_server = server_send_cipher.encrypt(server_message);

        let mut client_recv = recv_cipher;
        let decrypted_by_client = client_recv.decrypt(&encrypted_from_server);

        assert_eq!(
            server_message.as_slice(),
            decrypted_by_client.as_slice(),
            "Client should decrypt what server encrypted"
        );

        println!("Cipher roundtrip test passed!");
    }

    /// Test full packet roundtrip simulation (client->server direction)
    #[test]
    fn test_full_packet_roundtrip() {
        use crate::packet::{encode_packet, decode_packet, encrypt_packet};

        // Generate random params
        let params = HandshakeParams::generate();

        // Client derives ciphers
        let (_, send_cipher) = params.derive_ciphers();

        // Server derives recv cipher (should match client's send cipher)
        let server_recv_key: [u8; 32] = params.random_bytes[32..64].try_into().unwrap();
        let server_recv_iv: [u8; 16] = params.random_bytes[80..96].try_into().unwrap();
        let mut server_recv_cipher = AesCtrCipher::new(server_recv_key, server_recv_iv);

        // Client creates a packet
        let payload = b"liteServer.getTime query data here";
        let packet = encode_packet(payload);

        // Client encrypts with send_cipher
        let mut client_send = send_cipher;
        let encrypted = encrypt_packet(&packet, &mut client_send);

        // Server receives and decrypts
        // First, decrypt size (4 bytes)
        let decrypted_size_bytes = server_recv_cipher.decrypt(&encrypted[0..4]);
        let size = u32::from_le_bytes([
            decrypted_size_bytes[0],
            decrypted_size_bytes[1],
            decrypted_size_bytes[2],
            decrypted_size_bytes[3],
        ]) as usize;

        println!("Encrypted size bytes: {:02x?}", &encrypted[0..4]);
        println!("Decrypted size: {}", size);

        // Decrypt body
        let decrypted_body = server_recv_cipher.decrypt(&encrypted[4..]);

        // Reconstruct full decrypted packet
        let mut full_decrypted = decrypted_size_bytes;
        full_decrypted.extend(decrypted_body);

        // Decode packet
        let decoded = decode_packet(&full_decrypted).unwrap();

        assert_eq!(decoded, payload, "Server should correctly decode client's packet");
        println!("Full packet roundtrip test passed!");
    }

    #[test]
    fn test_handshake_params_generation() {
        let params1 = HandshakeParams::generate();
        let params2 = HandshakeParams::generate();

        // Two generated params should be different
        assert_ne!(params1.random_bytes, params2.random_bytes);
    }

    #[test]
    fn test_cipher_derivation() {
        let params = HandshakeParams::generate();

        // Test that ciphers work
        let plaintext = b"Hello, ADNL!";
        let (mut cipher_a, _) = params.derive_ciphers();
        let encrypted = cipher_a.encrypt(plaintext);

        // Decrypt with fresh cipher
        let (mut fresh_a, _) = params.derive_ciphers();
        let decrypted = fresh_a.decrypt(&encrypted);

        assert_eq!(plaintext.as_slice(), decrypted.as_slice());
    }

    #[test]
    fn test_handshake_packet_size() {
        let server_keypair = Ed25519Keypair::generate();
        let (packet, _) = perform_handshake(&server_keypair.public_key).unwrap();

        assert_eq!(packet.len(), HANDSHAKE_PACKET_SIZE);
    }

    #[test]
    fn test_checksum_consistency() {
        let params = HandshakeParams::generate();
        let checksum1 = params.checksum();
        let checksum2 = params.checksum();

        assert_eq!(checksum1, checksum2);
    }

    #[test]
    fn test_encrypt_handshake_params() {
        let params = HandshakeParams::generate();
        let shared_secret = [42u8; 32];

        let encrypted = encrypt_handshake_params(&params, &shared_secret);

        // Encrypted should be different from original
        assert_ne!(encrypted.as_slice(), params.random_bytes.as_slice());

        // Encrypted should be same size
        assert_eq!(encrypted.len(), HANDSHAKE_PARAMS_SIZE);
    }

    #[test]
    fn test_build_handshake_packet_structure() {
        let server_keypair = Ed25519Keypair::generate();
        let params = HandshakeParams::generate();

        let packet = build_handshake_packet(
            &server_keypair.public_key,
            &params,
        )
        .unwrap();

        // Check server key ID is at the beginning
        let expected_key_id = calculate_key_id(&server_keypair.public_key);
        assert_eq!(&packet[0..32], &expected_key_id);

        // Bytes 32-64 contain ephemeral pubkey (generated inside build_handshake_packet)
        // We can't check the exact value since it's random, but it should be 32 bytes
        assert_eq!(packet[32..64].len(), 32);

        // Check checksum follows
        assert_eq!(&packet[64..96], &params.checksum());

        // Encrypted params should be at the end (160 bytes)
        assert_eq!(packet[96..].len(), HANDSHAKE_PARAMS_SIZE);
    }
}

    /// Test using adnl-rs test vectors
    #[test]
    fn test_packet_encryption_with_adnl_rs_vectors() {
        use crate::packet::{encode_packet_with_nonce, encrypt_packet};
        use ton_crypto::aes_ctr::AesCtrCipher;
        
        // AES params from adnl-rs test_send_1
        // 160 bytes of random handshake data
        let aes_params = hex::decode(
            "b3d529e34b839a521518447b68343aebaae9314ac95aaacfdb687a2163d1a986\
             38db306b63409ef7bc906b4c9dc115488cf90dfa964f520542c69e1a4a495edf\
             9ae9ee72023203c8b266d552f251e8d7\
             24929733428c8e276ab3bd6291367336\
             a6ab8dc3d36243419bd0b742f76691a5dec14edbd50f7c1b58ec961ae45be58c\
             bf6623f3ec9705bd5d227761ec79cee377e2566ff668f863552bddfd6ff3a16b"
        ).unwrap();
        
        // Verify it's 160 bytes
        assert_eq!(aes_params.len(), 160, "AES params should be 160 bytes");
        
        // Extract cipher parameters
        // send_key = bytes[32..64]
        let send_key: [u8; 32] = aes_params[32..64].try_into().unwrap();
        // send_iv = bytes[80..96]
        let send_iv: [u8; 16] = aes_params[80..96].try_into().unwrap();
        
        println!("send_key: {:02x?}", &send_key);
        println!("send_iv: {:02x?}", &send_iv);
        
        let _send_cipher = AesCtrCipher::new(send_key, send_iv);
        
        // The input buffer from adnl-rs test (52 bytes)
        // This is the PAYLOAD - what goes inside nonce+checksum wrapper
        let payload = hex::decode(
            "7af98bb471ff48e9b263959b17a04faae4a23501380d2aa932b09eac6f9846fc\
             bae9bbcb0cdf068c7904345aad16000000000000"
        ).unwrap();
        
        println!("payload ({} bytes): {:02x?}", payload.len(), &payload);
        
        // Expected encrypted packet from adnl-rs
        let expected_encrypted = hex::decode(
            "250d70d08526791bc2b6278ded7bf2b051afb441b309dda06f76e4419d7c31d4\
             d5baafc4ff71e0ebabe246d4ea19e3e579bd15739c8fc916feaf46ea7a6bc562\
             ed1cf87c9bf4220eb037b9a0b58f663f0474b8a8b18fa24db515e41e4b02e509\
             d8ef261a27ba894cbbecc92e59fc44bf5ff7c8281cb5e900"
        ).unwrap();
        
        println!("expected encrypted ({} bytes): {:02x?}", expected_encrypted.len(), &expected_encrypted[..8]);
        
        // To match, we need to know what nonce adnl-rs used
        // The encrypted packet is 120 bytes = 4 (size) + 32 (nonce) + 52 (payload) + 32 (checksum)
        // Let's decrypt the expected to figure out the nonce
        let mut decrypt_cipher = AesCtrCipher::new(send_key, send_iv);
        let decrypted = decrypt_cipher.decrypt(&expected_encrypted);
        
        println!("decrypted packet: {:02x?}", &decrypted[..std::cmp::min(40, decrypted.len())]);
        
        // Extract size
        let size = u32::from_le_bytes([decrypted[0], decrypted[1], decrypted[2], decrypted[3]]);
        println!("decrypted size field: {}", size);
        
        // Extract nonce
        let nonce: [u8; 32] = decrypted[4..36].try_into().unwrap();
        println!("nonce from adnl-rs: {:02x?}", &nonce[..8]);
        
        // Now create our own packet with the same nonce
        let our_packet = encode_packet_with_nonce(&payload, &nonce);
        println!("our packet: {:02x?}", &our_packet[..std::cmp::min(40, our_packet.len())]);
        
        // Encrypt with fresh cipher
        let mut fresh_cipher = AesCtrCipher::new(send_key, send_iv);
        let our_encrypted = encrypt_packet(&our_packet, &mut fresh_cipher);
        
        println!("our encrypted: {:02x?}", &our_encrypted[..8]);
        println!("expected:      {:02x?}", &expected_encrypted[..8]);
        
        assert_eq!(our_encrypted.len(), expected_encrypted.len(), "Length should match");
        assert_eq!(&our_encrypted[..], &expected_encrypted[..], "Encryption should match");
    }

    /// Test simulating full client-server exchange
    #[test]
    fn test_full_client_server_exchange_simulation() {
        use crate::packet::{encode_packet_with_nonce, encrypt_packet, decode_packet};
        use ton_crypto::aes_ctr::AesCtrCipher;
        
        println!("\n=== Simulating full client-server exchange ===\n");
        
        // Client generates 160 random bytes (deterministic for testing)
        let mut random_bytes = [0u8; 160];
        for (i, byte) in random_bytes.iter_mut().enumerate() {
            *byte = (i * 7 + 13) as u8; // Deterministic "random"
        }
        
        // CLIENT: derive ciphers
        let client_recv_key: [u8; 32] = random_bytes[0..32].try_into().unwrap();
        let client_recv_iv: [u8; 16] = random_bytes[64..80].try_into().unwrap();
        let mut client_recv_cipher = AesCtrCipher::new(client_recv_key, client_recv_iv);
        
        let client_send_key: [u8; 32] = random_bytes[32..64].try_into().unwrap();
        let client_send_iv: [u8; 16] = random_bytes[80..96].try_into().unwrap();
        let mut client_send_cipher = AesCtrCipher::new(client_send_key, client_send_iv);
        
        // SERVER: receives same 160 bytes, derives ciphers (reversed roles)
        let server_send_key: [u8; 32] = random_bytes[0..32].try_into().unwrap();
        let server_send_iv: [u8; 16] = random_bytes[64..80].try_into().unwrap();
        let mut server_send_cipher = AesCtrCipher::new(server_send_key, server_send_iv);
        
        let server_recv_key: [u8; 32] = random_bytes[32..64].try_into().unwrap();
        let server_recv_iv: [u8; 16] = random_bytes[80..96].try_into().unwrap();
        let mut server_recv_cipher = AesCtrCipher::new(server_recv_key, server_recv_iv);
        
        println!("Client recv key: {:02x?}", &client_recv_key[0..4]);
        println!("Client send key: {:02x?}", &client_send_key[0..4]);
        println!("Server recv key: {:02x?}", &server_recv_key[0..4]);
        println!("Server send key: {:02x?}", &server_send_key[0..4]);
        
        // Verify cipher pairing
        assert_eq!(client_recv_key, server_send_key, "Client recv should match server send");
        assert_eq!(client_recv_iv, server_send_iv, "Client recv IV should match server send IV");
        assert_eq!(client_send_key, server_recv_key, "Client send should match server recv");
        assert_eq!(client_send_iv, server_recv_iv, "Client send IV should match server recv IV");
        println!("\nCipher pairing verified OK!\n");
        
        // STEP 1: Server sends empty confirmation
        println!("--- Step 1: Server sends empty confirmation ---");
        let nonce1: [u8; 32] = core::array::from_fn(|i| (i * 3) as u8);
        let server_empty_packet = encode_packet_with_nonce(&[], &nonce1);
        println!("Server plaintext confirmation: {} bytes", server_empty_packet.len());
        let server_encrypted = encrypt_packet(&server_empty_packet, &mut server_send_cipher);
        println!("Server encrypted confirmation: {} bytes", server_encrypted.len());
        println!("Encrypted[0..8]: {:02x?}", &server_encrypted[0..8]);
        
        // Client receives and decrypts
        let client_decrypted_size = client_recv_cipher.decrypt(&server_encrypted[0..4]);
        let size = u32::from_le_bytes([
            client_decrypted_size[0], client_decrypted_size[1],
            client_decrypted_size[2], client_decrypted_size[3],
        ]) as usize;
        println!("Client decrypted size: {}", size);
        
        let client_decrypted_body = client_recv_cipher.decrypt(&server_encrypted[4..]);
        let mut full_confirmation = client_decrypted_size;
        full_confirmation.extend_from_slice(&client_decrypted_body);
        
        let confirmation_payload = decode_packet(&full_confirmation).expect("Should decode");
        assert!(confirmation_payload.is_empty(), "Confirmation should have empty payload");
        println!("Client successfully received empty confirmation!\n");
        
        // STEP 2: Client sends query
        println!("--- Step 2: Client sends query ---");
        let query_payload = b"Hello, server!";
        let nonce2: [u8; 32] = core::array::from_fn(|i| (i * 5 + 1) as u8);
        let client_query_packet = encode_packet_with_nonce(query_payload, &nonce2);
        println!("Client plaintext query: {} bytes", client_query_packet.len());
        let client_encrypted = encrypt_packet(&client_query_packet, &mut client_send_cipher);
        println!("Client encrypted query: {} bytes", client_encrypted.len());
        println!("Encrypted[0..8]: {:02x?}", &client_encrypted[0..8]);
        
        // Server receives and decrypts
        let server_decrypted_size = server_recv_cipher.decrypt(&client_encrypted[0..4]);
        let size2 = u32::from_le_bytes([
            server_decrypted_size[0], server_decrypted_size[1],
            server_decrypted_size[2], server_decrypted_size[3],
        ]) as usize;
        println!("Server decrypted size: {}", size2);
        
        let server_decrypted_body = server_recv_cipher.decrypt(&client_encrypted[4..]);
        let mut full_query = server_decrypted_size;
        full_query.extend_from_slice(&server_decrypted_body);
        
        let query_result = decode_packet(&full_query).expect("Server should decode query");
        assert_eq!(query_result.as_slice(), query_payload, "Query payload should match");
        println!("Server successfully received query: {:?}", String::from_utf8_lossy(&query_result));
        
        println!("\n=== Full exchange simulation PASSED! ===\n");
    }
